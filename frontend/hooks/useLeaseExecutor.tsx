"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These will be generated by genabi script
// For now, we'll use placeholder types
type LeaseExecutorABI = any;
type LeaseExecutorAddresses = any;

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type Lease = {
  id: bigint;
  lessor: string;
  lessee: string;
  createdAt: bigint;
  updatedAt: bigint;
  isActive: boolean;
};

type LeaseExecutorInfoType = {
  abi: LeaseExecutorABI;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

// Dynamic import for generated ABI files
async function getLeaseExecutorByChainId(
  chainId: number | undefined
): Promise<LeaseExecutorInfoType> {
  try {
    const { LeaseExecutorABI } = await import("@/abi/LeaseExecutorABI");
    const { LeaseExecutorAddresses } = await import("@/abi/LeaseExecutorAddresses");

    if (!chainId) {
      return { abi: LeaseExecutorABI.abi };
    }

    const entry = LeaseExecutorAddresses[chainId.toString() as keyof typeof LeaseExecutorAddresses];

    // Ensure entry is defined before accessing properties to avoid `'in' on undefined`
    if (!entry?.address || entry.address === ethers.ZeroAddress) {
      return { abi: LeaseExecutorABI.abi, chainId };
    }

    return {
      address: entry?.address as `0x${string}` | undefined,
      chainId: entry?.chainId ?? chainId,
      chainName: entry?.chainName,
      abi: LeaseExecutorABI.abi,
    };
  } catch {
    // Fallback if ABI files don't exist yet
    return { abi: [] as any, chainId };
  }
}

export const useLeaseExecutor = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // State
  const [leases, setLeases] = useState<Lease[]>([]);
  const [selectedLeaseId, setSelectedLeaseId] = useState<bigint | undefined>(undefined);
  const [lesseeAddress, setLesseeAddress] = useState<string>("");
  const [usageCount, setUsageCount] = useState<number>(0);
  const [daysLeft, setDaysLeft] = useState<number>(0);
  const [paymentStatus, setPaymentStatus] = useState<number>(0);
  const [amountPaid, setAmountPaid] = useState<number>(0);

  // Encrypted handles
  const [termsHandles, setTermsHandles] = useState<{
    usageCount?: `0x${string}`;
    daysLeft?: `0x${string}`;
    paymentStatus?: `0x${string}`;
    amountPaid?: `0x${string}`;
  }>({});
  
  const [statesHandles, setStatesHandles] = useState<{
    expired?: `0x${string}`;
    violation?: `0x${string}`;
    refund?: `0x${string}`;
  }>({});

  // Decrypted values
  const [clearTerms, setClearTerms] = useState<{
    usageCount?: bigint;
    daysLeft?: bigint;
    paymentStatus?: bigint;
    amountPaid?: bigint;
  }>();
  
  const [clearStates, setClearStates] = useState<{
    expired?: bigint;
    violation?: bigint;
    refund?: bigint;
  }>();

  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecryptingTerms, setIsDecryptingTerms] = useState<boolean>(false);
  const [isDecryptingStates, setIsDecryptingStates] = useState<boolean>(false);
  const [isCreatingLease, setIsCreatingLease] = useState<boolean>(false);
  const [isUpdatingLease, setIsUpdatingLease] = useState<boolean>(false);
  const [isClosingLease, setIsClosingLease] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const leaseExecutorRef = useRef<LeaseExecutorInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isCreatingLeaseRef = useRef<boolean>(isCreatingLease);
  const isUpdatingLeaseRef = useRef<boolean>(isUpdatingLease);

  const [leaseExecutor, setLeaseExecutor] = useState<LeaseExecutorInfoType | undefined>(undefined);

  useEffect(() => {
    getLeaseExecutorByChainId(chainId).then((c) => {
      leaseExecutorRef.current = c;
      setLeaseExecutor(c);
      if (!c.address) {
        setMessage(`LeaseExecutor deployment not found for chainId=${chainId}.`);
      }
    });
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!leaseExecutor) {
      return undefined;
    }
    return Boolean(leaseExecutor.address) && leaseExecutor.address !== ethers.ZeroAddress;
  }, [leaseExecutor]);

  // Refresh leases list
  const refreshLeases = useCallback(async () => {
    if (!leaseExecutor?.address || !ethersReadonlyProvider || !ethersSigner) {
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    try {
      const contract = new ethers.Contract(
        leaseExecutor.address,
        leaseExecutor.abi,
        ethersReadonlyProvider
      );

      const userAddress = await ethersSigner.getAddress();

      // Helper: silently return empty list when no data (value="0x")/BAD_DATA on fresh state
      const safeLoadIds = async (fn: () => Promise<readonly bigint[]>) => {
        try {
          return await fn();
        } catch (err: any) {
          const msg = String(err?.message ?? err ?? "");
          const code = (err && (err as any).code) || "";
          if (
            code === "BAD_DATA" ||
            code === "CALL_EXCEPTION" ||
            msg.includes("could not decode result data") ||
            msg.includes("value=\"0x\"")
          ) {
            // Treat as no leases yet
            return [] as unknown as readonly bigint[];
          }
          throw err;
        }
      };

      const lesseeLeases = await safeLoadIds(() => contract.getLesseeLeases(userAddress));
      const lessorLeases = await safeLoadIds(() => contract.getLessorLeases(userAddress));

      const allLeaseIds = [...new Set([...lesseeLeases, ...lessorLeases])];
      const leaseList: Lease[] = [];

      for (const id of allLeaseIds) {
        try {
          const leaseInfo = await contract.getLeaseInfo(id);
          leaseList.push({
            id: leaseInfo.id,
            lessor: leaseInfo.lessor,
            lessee: leaseInfo.lessee,
            createdAt: leaseInfo.createdAt,
            updatedAt: leaseInfo.updatedAt,
            isActive: leaseInfo.isActive,
          });
        } catch (e) {
          console.error(`Failed to load lease ${id}:`, e);
        }
      }

      setLeases(leaseList);
      isRefreshingRef.current = false;
      setIsRefreshing(false);
    } catch (e) {
      const msg = String((e as any)?.message ?? e ?? "");
      const code = (e as any)?.code ?? "";
      const shortMsg = String((e as any)?.shortMessage ?? "");
      const combined = `${msg} ${shortMsg}`.toLowerCase();

      // Silently ignore and treat as empty state for initial no-data cases
      if (
        code === "BAD_DATA" ||
        code === "CALL_EXCEPTION" ||
        combined.includes("could not decode result data") ||
        combined.includes('value="0x"') ||
        combined.includes("missing return data")
      ) {
        setLeases([]);
      } else {
        // For unexpected errors, still surface
        setMessage("Failed to load leases: " + e);
      }

      isRefreshingRef.current = false;
      setIsRefreshing(false);
    }
  }, [leaseExecutor?.address, leaseExecutor?.abi, ethersReadonlyProvider, ethersSigner]);

  // Select lease and load encrypted handles
  const selectLease = useCallback(async (leaseId: bigint) => {
    if (!leaseExecutor?.address || !ethersReadonlyProvider) {
      return;
    }

    setSelectedLeaseId(leaseId);
    setClearTerms(undefined);
    setClearStates(undefined);
    setTermsHandles({});
    setStatesHandles({});

    try {
      const contract = new ethers.Contract(
        leaseExecutor.address,
        leaseExecutor.abi,
        ethersReadonlyProvider
      );

      const [usageCountHandle, daysLeftHandle, paymentStatusHandle, amountPaidHandle] =
        await contract.getEncryptedLeaseTerms(leaseId);
      
      setTermsHandles({
        usageCount: usageCountHandle,
        daysLeft: daysLeftHandle,
        paymentStatus: paymentStatusHandle,
        amountPaid: amountPaidHandle,
      });

      const [expiredHandle, violationHandle, refundHandle] =
        await contract.getEncryptedStates(leaseId);
      
      setStatesHandles({
        expired: expiredHandle,
        violation: violationHandle,
        refund: refundHandle,
      });
    } catch (e) {
      setMessage("Failed to load lease handles: " + e);
    }
  }, [leaseExecutor?.address, leaseExecutor?.abi, ethersReadonlyProvider]);

  // Decrypt terms
  const decryptTerms = useCallback(async () => {
    if (
      !termsHandles.usageCount ||
      !termsHandles.daysLeft ||
      !termsHandles.paymentStatus ||
      !termsHandles.amountPaid ||
      !instance ||
      !ethersSigner ||
      !leaseExecutor?.address ||
      isDecryptingTerms
    ) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = leaseExecutor.address;
    const thisEthersSigner = ethersSigner;

    setIsDecryptingTerms(true);
    setMessage("Starting terms decryption...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== leaseExecutorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [leaseExecutor.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Calling FHEVM userDecrypt for terms...");

        const res = await instance.userDecrypt(
          [
            { handle: termsHandles.usageCount!, contractAddress: thisAddress },
            { handle: termsHandles.daysLeft!, contractAddress: thisAddress },
            { handle: termsHandles.paymentStatus!, contractAddress: thisAddress },
            { handle: termsHandles.amountPaid!, contractAddress: thisAddress },
          ],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("Terms decryption completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        // Helper function to convert to bigint
        const toBigInt = (value: string | bigint | boolean | undefined): bigint | undefined => {
          if (value === undefined) return undefined;
          if (typeof value === 'bigint') return value;
          if (typeof value === 'string') return BigInt(value);
          if (typeof value === 'boolean') return BigInt(value ? 1 : 0);
          return undefined;
        };

        setClearTerms({
          usageCount: toBigInt(res[termsHandles.usageCount!]),
          daysLeft: toBigInt(res[termsHandles.daysLeft!]),
          paymentStatus: toBigInt(res[termsHandles.paymentStatus!]),
          amountPaid: toBigInt(res[termsHandles.amountPaid!]),
        });
      } catch (e) {
        setMessage("Decryption failed: " + e);
      } finally {
        setIsDecryptingTerms(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    leaseExecutor?.address,
    instance,
    termsHandles,
    chainId,
    sameChain,
    sameSigner,
  ]);

  // Decrypt states
  const decryptStates = useCallback(async () => {
    if (
      !statesHandles.expired ||
      !statesHandles.violation ||
      !statesHandles.refund ||
      !instance ||
      !ethersSigner ||
      !leaseExecutor?.address ||
      isDecryptingStates
    ) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = leaseExecutor.address;
    const thisEthersSigner = ethersSigner;

    setIsDecryptingStates(true);
    setMessage("Starting states decryption...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== leaseExecutorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [leaseExecutor.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Calling FHEVM userDecrypt for states...");

        const res = await instance.userDecrypt(
          [
            { handle: statesHandles.expired!, contractAddress: thisAddress },
            { handle: statesHandles.violation!, contractAddress: thisAddress },
            { handle: statesHandles.refund!, contractAddress: thisAddress },
          ],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("States decryption completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        // Helper function to convert to bigint
        const toBigInt = (value: string | bigint | boolean | undefined): bigint | undefined => {
          if (value === undefined) return undefined;
          if (typeof value === 'bigint') return value;
          if (typeof value === 'string') return BigInt(value);
          if (typeof value === 'boolean') return BigInt(value ? 1 : 0);
          return undefined;
        };

        setClearStates({
          expired: toBigInt(res[statesHandles.expired!]),
          violation: toBigInt(res[statesHandles.violation!]),
          refund: toBigInt(res[statesHandles.refund!]),
        });
      } catch (e) {
        setMessage("Decryption failed: " + e);
      } finally {
        setIsDecryptingStates(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    leaseExecutor?.address,
    instance,
    statesHandles,
    chainId,
    sameChain,
    sameSigner,
  ]);

  // Create lease
  const createLease = useCallback(() => {
    if (
      isCreatingLeaseRef.current ||
      !leaseExecutor?.address ||
      !instance ||
      !ethersSigner ||
      !lesseeAddress ||
      !ethers.isAddress(lesseeAddress)
    ) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = leaseExecutor.address;
    const thisEthersSigner = ethersSigner;
    const contract = new ethers.Contract(
      thisAddress,
      leaseExecutor.abi,
      thisEthersSigner
    );

    isCreatingLeaseRef.current = true;
    setIsCreatingLease(true);
    setMessage("Encrypting lease terms...");

    const run = async () => {
      await new Promise((resolve) => setTimeout(resolve, 100));

      const isStale = () =>
        thisAddress !== leaseExecutorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const input = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );

        input.add32(usageCount);
        const encUsageCount = await input.encrypt();

        const input2 = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        input2.add32(daysLeft);
        const encDaysLeft = await input2.encrypt();

        const input3 = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        input3.add32(paymentStatus);
        const encPaymentStatus = await input3.encrypt();

        const input4 = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        // Convert ETH to Gwei (multiply by 1e9) for 32-bit integer compatibility
        // euint32 can only store values up to 4294967295
        // 1 ETH = 1,000,000,000 Gwei, so max supported is ~4.29 ETH
        const amountPaidInGwei = BigInt(Math.floor(amountPaid * 1e9));
        if (amountPaidInGwei > BigInt(4294967295)) {
          throw new Error(`Amount too large. Maximum supported is ~4.29 ETH (4294967295 Gwei).`);
        }
        input4.add32(Number(amountPaidInGwei));
        const encAmountPaid = await input4.encrypt();

        if (isStale()) {
          setMessage("Ignore create lease");
          return;
        }

        setMessage("Submitting lease creation transaction...");

        const tx: ethers.TransactionResponse = await contract.createLease(
          lesseeAddress,
          encUsageCount.handles[0],
          encDaysLeft.handles[0],
          encPaymentStatus.handles[0],
          encAmountPaid.handles[0],
          encUsageCount.inputProof,
          encDaysLeft.inputProof,
          encPaymentStatus.inputProof,
          encAmountPaid.inputProof
        );

        setMessage(`Waiting for transaction: ${tx.hash}...`);

        const receipt = await tx.wait();

        setMessage(`Lease created! Status: ${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore create lease");
          return;
        }

        await refreshLeases();
      } catch (e) {
        setMessage(`Lease creation failed: ${e}`);
      } finally {
        isCreatingLeaseRef.current = false;
        setIsCreatingLease(false);
      }
    };

    run();
  }, [
    ethersSigner,
    leaseExecutor?.address,
    leaseExecutor?.abi,
    instance,
    chainId,
    refreshLeases,
    sameChain,
    sameSigner,
    lesseeAddress,
    usageCount,
    daysLeft,
    paymentStatus,
    amountPaid,
  ]);

  // Update lease
  const updateSelectedLease = useCallback((overrides?: { usageCount?: number; daysLeft?: number; paymentStatus?: number }) => {
    if (
      !selectedLeaseId ||
      isUpdatingLeaseRef.current ||
      !leaseExecutor?.address ||
      !instance ||
      !ethersSigner
    ) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = leaseExecutor.address;
    const thisEthersSigner = ethersSigner;
    const contract = new ethers.Contract(
      thisAddress,
      leaseExecutor.abi,
      thisEthersSigner
    );

    isUpdatingLeaseRef.current = true;
    setIsUpdatingLease(true);
    setMessage("Encrypting updated lease terms...");

    const run = async () => {
      await new Promise((resolve) => setTimeout(resolve, 100));

      const isStale = () =>
        thisAddress !== leaseExecutorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const nextUsageCount = overrides?.usageCount ?? usageCount;
        const nextDaysLeft = overrides?.daysLeft ?? daysLeft;
        const nextPaymentStatus = overrides?.paymentStatus ?? paymentStatus;

        const input = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        input.add32(nextUsageCount);
        const encUsageCount = await input.encrypt();

        const input2 = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        input2.add32(nextDaysLeft);
        const encDaysLeft = await input2.encrypt();

        const input3 = instance.createEncryptedInput(
          thisAddress,
          thisEthersSigner.address
        );
        input3.add32(nextPaymentStatus);
        const encPaymentStatus = await input3.encrypt();

        if (isStale()) {
          setMessage("Ignore update lease");
          return;
        }

        setMessage("Submitting lease update transaction...");

        const tx: ethers.TransactionResponse = await contract.updateLease(
          selectedLeaseId,
          encUsageCount.handles[0],
          encDaysLeft.handles[0],
          encPaymentStatus.handles[0],
          encUsageCount.inputProof,
          encDaysLeft.inputProof,
          encPaymentStatus.inputProof
        );

        setMessage(`Waiting for transaction: ${tx.hash}...`);

        const receipt = await tx.wait();

        setMessage(`Lease updated! Status: ${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore update lease");
          return;
        }

        await selectLease(selectedLeaseId);
        await refreshLeases();
      } catch (e) {
        setMessage(`Lease update failed: ${e}`);
      } finally {
        isUpdatingLeaseRef.current = false;
        setIsUpdatingLease(false);
      }
    };

    run();
  }, [
    ethersSigner,
    leaseExecutor?.address,
    leaseExecutor?.abi,
    instance,
    chainId,
    refreshLeases,
    selectLease,
    sameChain,
    sameSigner,
    selectedLeaseId,
    usageCount,
    daysLeft,
    paymentStatus,
  ]);

  // Close lease
  const closeLease = useCallback(
    async (leaseId: bigint) => {
      if (!leaseExecutor?.address || !ethersSigner || isClosingLease) {
        return;
      }

      setIsClosingLease(true);
      setMessage("Closing lease...");

      const run = async () => {
        try {
          const contract = new ethers.Contract(
            leaseExecutor.address!,
            leaseExecutor.abi,
            ethersSigner
          );

          const tx = await contract.closeLease(leaseId);
          setMessage(`Waiting for transaction: ${tx.hash}...`);

          const receipt = await tx.wait();
          setMessage(`Lease closed! Status: ${receipt?.status}`);

          await refreshLeases();
        } catch (e) {
          setMessage(`Close lease failed: ${e}`);
        } finally {
          setIsClosingLease(false);
        }
      };

      run();
    },
    [leaseExecutor?.address, leaseExecutor?.abi, ethersSigner, refreshLeases]
  );

  // Auto refresh on mount
  useEffect(() => {
    refreshLeases();
  }, [refreshLeases]);

  return {
    contractAddress: leaseExecutor?.address,
    isDeployed,
    leases,
    selectedLeaseId,
    lesseeAddress,
    setLesseeAddress,
    usageCount,
    setUsageCount,
    daysLeft,
    setDaysLeft,
    paymentStatus,
    setPaymentStatus,
    amountPaid,
    setAmountPaid,
    clearTerms,
    clearStates,
    isRefreshing,
    isDecryptingTerms,
    isDecryptingStates,
    isCreatingLease,
    isUpdatingLease,
    isClosingLease,
    message,
    refreshLeases,
    selectLease,
    decryptTerms,
    decryptStates,
    createLease,
    updateSelectedLease,
    closeLease,
    canCreateLease: Boolean(
      leaseExecutor?.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isCreatingLease &&
      lesseeAddress &&
      ethers.isAddress(lesseeAddress)
    ),
    canRefreshLeases: Boolean(
      leaseExecutor?.address && ethersReadonlyProvider && !isRefreshing
    ),
    canSelectLease: Boolean(
      leaseExecutor?.address && ethersReadonlyProvider && !isRefreshing
    ),
    canDecryptTerms: Boolean(
      leaseExecutor?.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecryptingTerms &&
      termsHandles.usageCount &&
      termsHandles.daysLeft &&
      termsHandles.paymentStatus &&
      termsHandles.amountPaid
    ),
    canDecryptStates: Boolean(
      leaseExecutor?.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecryptingStates &&
      statesHandles.expired &&
      statesHandles.violation &&
      statesHandles.refund
    ),
    canUpdateLease: Boolean(
      leaseExecutor?.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isUpdatingLease &&
      selectedLeaseId
    ),
    canCloseLease: Boolean(
      leaseExecutor?.address &&
      ethersSigner &&
      !isRefreshing &&
      !isClosingLease
    ),
  };
};
